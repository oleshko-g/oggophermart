// Package balance is an implementation of [genBalance] service generated by goa design
package balance

import (
	"context"
	"errors"
	"log/slog"
	"time"

	"github.com/EClaesson/go-luhn"
	"github.com/google/uuid"
	genBalance "github.com/oleshko-g/oggophermart/internal/gen/balance"
	genAccrualHTTPClient "github.com/oleshko-g/oggophermart/internal/gen/http/accrual/client"
	"github.com/oleshko-g/oggophermart/internal/service"
	svcErrors "github.com/oleshko-g/oggophermart/internal/service/errors"
	"github.com/oleshko-g/oggophermart/internal/storage"
	storageErrors "github.com/oleshko-g/oggophermart/internal/storage/errors"
)

type balanceSvc struct {
	storage.Balance
	service.Auther
	accrualOrdersToProcess chan uuid.UUID
	accruedOrders          chan accrualOrder
}

var _ genBalance.Service = (*balanceSvc)(nil)
var _ genBalance.Auther = (*balanceSvc)(nil)

// New returns the balance service implementation.
func New(storage storage.Balance, auther service.Auther) *balanceSvc {
	return &balanceSvc{
		Balance:                storage,
		Auther:                 auther,
		accrualOrdersToProcess: make(chan uuid.UUID),
	}
}

// PostOrder implements post order.
func (s *balanceSvc) UploadUserOrder(ctx context.Context, payload *genBalance.UploadUserOrderPayload) (res *genBalance.UploadUserOrderResult, err error) {
	ctx, err = s.Auther.JWTAuth(ctx, payload.Authorization, nil)
	if err != nil {
		return nil, err
	}

	userID, err := s.Auther.UserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	err = checkOrderNumber(payload.OrderNumber)
	if err != nil {
		return nil, err
	}

	dbUserID, err := s.RetreiveOrderUser(ctx, payload.OrderNumber)
	if err != nil {
		if !errors.Is(err, storageErrors.ErrNotFound) {
			return nil, err
		}
	} else if dbUserID != userID {
		return nil, ErrOwnerMismatch
	}

	res = &genBalance.UploadUserOrderResult{
		Accepted: nil,
	}
	if dbUserID == userID {
		return res, nil
	}

	err = s.StoreOrder(ctx, userID, payload.OrderNumber, OrderStatusNew, time.Now().UTC())
	if err != nil {
		return nil, svcErrors.ErrInternalServiceError
	}
	accepted := "yes"
	res.Accepted = &accepted
	return res, nil
}

// Orders statuses
const (
	OrderStatusNew        = "NEW"
	OrderStatusProcessing = "PROCESSING"
	OrderStatusProcessed  = "PROCESSED"
	OrderStatusInvalid    = "INVALID"
)

func checkOrderNumber(orderNumber string) error {

	valid, err := luhn.IsValid(orderNumber)
	if err != nil {
		return err
	}

	if !valid {
		return ErrInvalidOrderNumber
	}

	return nil
}

func (s *balanceSvc) ListUserOrders(ctx context.Context, payload *genBalance.ListUserOrdersPayload) (res *genBalance.ListUserOrdersResult, err error) {

	ctx, err = s.Auther.JWTAuth(ctx, payload.Authorization, nil)
	if err != nil {
		return nil, err
	}

	userID, err := s.Auther.UserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	ordersByUserID, err := s.RetrieaveUserOrders(ctx, userID)
	if err != nil {
		return nil, err
	}

	res = new(genBalance.ListUserOrdersResult)
	if ordersByUserID == nil {
		noOrders := "yes"
		res.NoOrders = &noOrders
		return res, nil
	}

	for _, v := range ordersByUserID {
		userOrder := &genBalance.Order{
			Number:     v.Number,
			Status:     v.Status,
			UploadedAt: v.CreatedAt.Format(time.RFC3339),
		}
		res.Orders = append(res.Orders, userOrder)
	}

	return res, nil
}

func (s *balanceSvc) GetUserBalance(ctx context.Context, payload *genBalance.GetUserBalancePayload) (res *genBalance.GetUserBalanceResult, err error) {
	ctx, err = s.Auther.JWTAuth(ctx, payload.Authorization, nil)
	if err != nil {
		return nil, err
	}

	userID, err := s.Auther.UserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	userBalance, err := s.Balance.Retrieve(ctx, userID)
	if err != nil {
		return &genBalance.GetUserBalanceResult{}, err
	}
	return &genBalance.GetUserBalanceResult{
		Current:   float64((userBalance.Current / 100)),
		Withdrawn: float64((userBalance.WithdrawnSum / 100)),
	}, nil
}

func (s *balanceSvc) WithdrawUserBalance(context.Context, *genBalance.WithdrawUserBalancePayload) (err error) {
	return nil
}

func (s *balanceSvc) ProcessAccruals(ctx context.Context, client genAccrualHTTPClient.Client) error {
	errCh := make(chan error, 1)
	s.accrualOrdersToProcess = make(chan uuid.UUID)

	go func() {
		orderIDs, err := s.RetrieveOrderIDsForAccrual(ctx)
		if err != nil {
			errCh <- err
		}
		errCh <- s.sendAccrualOrdersToProcess(orderIDs)
	}()

	for {
		select {
		case orderID := <-s.accrualOrdersToProcess:
			go func() {
				err := s.proccessAccrual(ctx, orderID, client)
				if err != nil {
					s.accrualOrdersToProcess <- orderID
					errCh <- err
				}
			}()
		case <-ctx.Done():
			return context.Cause(ctx)
		case err := <-errCh:
			slog.Error(err.Error())
			// TODO: log err through loggingCtx
		}
	}

}

func (s *balanceSvc) sendAccrualOrdersToProcess(orderIDs []uuid.UUID) error {
	if s.accrualOrdersToProcess == nil { // guards against no reader on the channel
		return ErrAccrualProcessingNotStarted
	}

	for _, orderID := range orderIDs {
		s.accrualOrdersToProcess <- orderID
	}

	return nil
}

func (s *balanceSvc) proccessAccrual(ctx context.Context, orderID uuid.UUID, client genAccrualHTTPClient.Client) error {
	errCh := make(chan error, 1)
	accrualResult := make(chan accrualOrder, 1)

	// start storate transaction
	storageTx, err := s.Balance.BeginTx(ctx)
	if err != nil {
		errCh <- err
	}
	defer storageTx.Tx.Rollback()

	orderNumber, err := storageTx.RetrieveOrderNumberForAccrual(ctx, orderID)
	// TODO: add status == PROCESSED check

	go func() {
		res, err := getOrderAccrual(ctx, orderNumber, client)
		if err != nil {
			errCh <- err
		}

		accrualResult <- accrualOrder{
			orderNumber: *res.Order,
			status:      *res.Status,
			accruel:     res.Accrual,
		}
	}()

	select {
	case accruedOrder := <-accrualResult:
		switch {
		case accruedOrder.status == "PROCESSED" && accruedOrder.accruel != nil:
			// TODO: s.StoreOrderTransaction
		}
		storageTx.UpdateOrderStatus(ctx, orderID, accruedOrder.status)
	case err := <-errCh:
		return err
	case <-ctx.Done():
		return context.Cause(ctx)
	}

	err = storageTx.Tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func getOrderAccrual(ctx context.Context, orderNumber string, client genAccrualHTTPClient.Client) (genAccrualHTTPClient.GetOrderAccrualOKResponseBody, error) {
	getOrderAccrual := client.GetOrderAccrual()

	reqBody, err := genAccrualHTTPClient.BuildGetOrderAccrualPayload(orderNumber)
	if err != nil {
		return genAccrualHTTPClient.GetOrderAccrualOKResponseBody{}, err
	}

	orderAccrual, err := getOrderAccrual(ctx, reqBody)
	if err != nil {
		return genAccrualHTTPClient.GetOrderAccrualOKResponseBody{}, err
	}

	v, ok := orderAccrual.(genAccrualHTTPClient.GetOrderAccrualOKResponseBody)
	if !ok {
		return genAccrualHTTPClient.GetOrderAccrualOKResponseBody{}, ErrFailedToGetOrderAccrual
	}

	return v, nil
}

type accrualOrder struct {
	orderNumber string
	status      string
	accruel     *float64
}
