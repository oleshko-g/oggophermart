// Package balance is an implementation of [genBalance] service generated by goa design
package balance

import (
	"context"
	"errors"
	"log/slog"
	"time"

	accrualHTTP "github.com/oleshko-g/oggophermart/internal/transport/http/accrual"

	"github.com/EClaesson/go-luhn"
	"github.com/google/uuid"
	genBalance "github.com/oleshko-g/oggophermart/internal/gen/balance"
	"github.com/oleshko-g/oggophermart/internal/service"
	svcErrors "github.com/oleshko-g/oggophermart/internal/service/errors"
	"github.com/oleshko-g/oggophermart/internal/storage"
	storageErrors "github.com/oleshko-g/oggophermart/internal/storage/errors"
)

type balanceSvc struct {
	storage.Balance
	service.Auther
	accrualClient          *accrualHTTP.Client
	accrualOrdersToProcess chan uuid.UUID
}

var _ genBalance.Service = (*balanceSvc)(nil)
var _ genBalance.Auther = (*balanceSvc)(nil)

// New returns the balance service implementation.
func New(storage storage.Balance, auther service.Auther, c *accrualHTTP.Client) *balanceSvc {
	return &balanceSvc{
		Balance:                storage,
		Auther:                 auther,
		accrualOrdersToProcess: make(chan uuid.UUID),
		accrualClient:          c,
	}
}

// PostOrder implements post order.
func (s *balanceSvc) UploadUserOrder(ctx context.Context, payload *genBalance.UploadUserOrderPayload) (res *genBalance.UploadUserOrderResult, err error) {
	ctx, err = s.Auther.JWTAuth(ctx, payload.Authorization, nil)
	if err != nil {
		return nil, err
	}

	userID, err := s.Auther.UserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	err = checkOrderNumber(payload.OrderNumber)
	if err != nil {
		return nil, err
	}

	dbUserID, err := s.RetreiveOrderUser(ctx, payload.OrderNumber)
	if err != nil {
		if !errors.Is(err, storageErrors.ErrNotFound) {
			return nil, err
		}
	} else if dbUserID != userID {
		return nil, ErrOwnerMismatch
	}

	res = &genBalance.UploadUserOrderResult{
		Accepted: nil,
	}
	if dbUserID == userID {
		return res, nil
	}

	err = s.StoreOrder(ctx, userID, payload.OrderNumber, OrderStatusNew, time.Now().UTC())
	if err != nil {
		return nil, svcErrors.ErrInternalServiceError
	}
	accepted := "yes"
	res.Accepted = &accepted
	return res, nil
}

// Orders statuses
const (
	OrderStatusNew        = "NEW"
	OrderStatusProcessing = "PROCESSING"
	OrderStatusProcessed  = "PROCESSED"
	OrderStatusInvalid    = "INVALID"
)

func checkOrderNumber(orderNumber string) error {

	valid, err := luhn.IsValid(orderNumber)
	if err != nil {
		return err
	}

	if !valid {
		return ErrInvalidOrderNumber
	}

	return nil
}

func (s *balanceSvc) ListUserOrders(ctx context.Context, payload *genBalance.ListUserOrdersPayload) (res *genBalance.ListUserOrdersResult, err error) {

	ctx, err = s.Auther.JWTAuth(ctx, payload.Authorization, nil)
	if err != nil {
		return nil, err
	}

	userID, err := s.Auther.UserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	ordersByUserID, err := s.RetrieaveUserOrders(ctx, userID)
	if err != nil {
		return nil, err
	}

	res = new(genBalance.ListUserOrdersResult)
	if ordersByUserID == nil {
		noOrders := "yes"
		res.NoOrders = &noOrders
		return res, nil
	}

	for _, v := range ordersByUserID {
		userOrder := &genBalance.Order{
			Number:     v.Number,
			Status:     v.Status,
			UploadedAt: v.CreatedAt.Format(time.RFC3339),
		}
		res.Orders = append(res.Orders, userOrder)
	}

	return res, nil
}

func (s *balanceSvc) GetUserBalance(ctx context.Context, payload *genBalance.GetUserBalancePayload) (res *genBalance.GetUserBalanceResult, err error) {
	ctx, err = s.Auther.JWTAuth(ctx, payload.Authorization, nil)
	if err != nil {
		return nil, err
	}

	userID, err := s.Auther.UserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	userBalance, err := s.Balance.Retrieve(ctx, userID)
	if err != nil {
		return &genBalance.GetUserBalanceResult{}, err
	}
	return &genBalance.GetUserBalanceResult{
		Current:   float64((userBalance.Current / 100)),
		Withdrawn: float64((userBalance.WithdrawnSum / 100)),
	}, nil
}

func (s *balanceSvc) WithdrawUserBalance(context.Context, *genBalance.WithdrawUserBalancePayload) (err error) {
	return nil
}

func (s *balanceSvc) ProcessAccruals(ctx context.Context) error {
	s.accrualOrdersToProcess = make(chan uuid.UUID)

	orderIDs, err := s.RetrieveOrderIDsForAccrual(ctx)
	if err != nil {
		return err
	}
	err = s.sendAccrualOrdersToProcess(orderIDs)
	if err != nil {
		return err
	}

	errCh := make(chan error, 1)
	for {
		select {
		case orderID := <-s.accrualOrdersToProcess:
			go func() {
				err := s.processAccrual(ctx, orderID)
				if err != nil {
					s.accrualOrdersToProcess <- orderID
					errCh <- err
				}
			}()
		case <-ctx.Done():
			return context.Cause(ctx)
		case err := <-errCh:
			slog.Error(err.Error())
			// TODO: log err through loggingCtx
		}
	}

}

func (s *balanceSvc) sendAccrualOrdersToProcess(orderIDs []uuid.UUID) error {
	if s.accrualOrdersToProcess == nil { // guards against no reader on the channel
		return ErrProcessAccrualsNotStarted
	}

	for _, orderID := range orderIDs {
		s.accrualOrdersToProcess <- orderID
	}

	return nil
}

func (s *balanceSvc) processAccrual(ctx context.Context, orderID uuid.UUID) error {
	errCh := make(chan error, 1)
	accrualResult := make(chan orderAccrual, 1)
	ctx, cancelCause := context.WithCancelCause(ctx)
	defer cancelCause(nil)
	// start storate transaction
	storageTx, err := s.Balance.BeginTx(ctx)
	if err != nil {
		errCh <- err
	}

	orderNumber, err := storageTx.RetrieveOrderNumberForAccrual(ctx, orderID)
	// TODO: add status == PROCESSED check

	go func() {
		res, err := s.getOrderAccrual(ctx, orderNumber)
		if err != nil {
			errCh <- err
			return
		}

		if res == nil {
			return
		}

		accrualResult <- *res
	}()

	select {
	case accruedOrder := <-accrualResult:
		switch {
		case accruedOrder.status == "PROCESSED" && accruedOrder.amount != nil:
			// TODO: s.StoreOrderTransaction
		}
		storageTx.UpdateOrderStatus(ctx, orderID, accruedOrder.status)
		// TODO: add err check
	case err := <-errCh:
		defer cancelCause(err)
		return err
	case <-ctx.Done():
		return context.Cause(ctx)
	}

	err = storageTx.Tx.Commit()
	if err != nil {
		return err
	}
	return nil
}

func (s *balanceSvc) getOrderAccrual(ctx context.Context, orderNumber string) (*orderAccrual, error) {
	res, err := s.accrualClient.FetchOrderAccrual(ctx, accrualHTTP.FetchOrderAccrualPayload{Number: orderNumber})
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return &orderAccrual{number: res.Order, status: res.Status, amount: res.Accrual}, nil
}

type orderAccrual struct {
	number string
	status string
	amount *float64
}
