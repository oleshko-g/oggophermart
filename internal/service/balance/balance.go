// Package balance is an implementation of [genBalance] service generated by goa design
package balance

import (
	"context"
	"errors"
	"time"

	"github.com/EClaesson/go-luhn"
	genBalance "github.com/oleshko-g/oggophermart/internal/gen/balance"
	genAccrualHTTPClient "github.com/oleshko-g/oggophermart/internal/gen/http/accrual/client"
	"github.com/oleshko-g/oggophermart/internal/service"
	svcErrors "github.com/oleshko-g/oggophermart/internal/service/errors"
	"github.com/oleshko-g/oggophermart/internal/storage"
	storageErrors "github.com/oleshko-g/oggophermart/internal/storage/errors"
)

type balanceSvc struct {
	storage.Balance
	service.Auther
}

var _ genBalance.Service = (*balanceSvc)(nil)
var _ genBalance.Auther = (*balanceSvc)(nil)

// New returns the balance service implementation.
func New(storage storage.Balance, auther service.Auther) *balanceSvc {
	return &balanceSvc{
		Balance: storage,
		Auther:  auther,
	}
}

// PostOrder implements post order.
func (s *balanceSvc) UploadUserOrder(ctx context.Context, payload *genBalance.UploadUserOrderPayload) (res *genBalance.UploadUserOrderResult, err error) {
	ctx, err = s.Auther.JWTAuth(ctx, payload.Authorization, nil)
	if err != nil {
		return nil, err
	}

	userID, err := s.Auther.UserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	err = checkOrderNumber(payload.OrderNumber)
	if err != nil {
		return nil, err
	}

	dbUserID, err := s.RetreiveOrderUser(ctx, payload.OrderNumber)
	if err != nil {
		if !errors.Is(err, storageErrors.ErrNotFound) {
			return nil, err
		}
	} else if dbUserID != userID {
		return nil, ErrOwnerMismatch
	}

	res = &genBalance.UploadUserOrderResult{
		Accepted: nil,
	}
	if dbUserID == userID {
		return res, nil
	}

	err = s.StoreOrder(ctx, userID, payload.OrderNumber, OrderStatusNew, time.Now().UTC())
	if err != nil {
		return nil, svcErrors.ErrInternalServiceError
	}
	accepted := "yes"
	res.Accepted = &accepted
	return res, nil
}

// Orders statuses
const (
	OrderStatusNew        = "NEW"
	OrderStatusProcessing = "PROCESSING"
	OrderStatusProcessed  = "PROCESSED"
	OrderStatusInvalid    = "INVALID"
)

func checkOrderNumber(orderNumber string) error {

	valid, err := luhn.IsValid(orderNumber)
	if err != nil {
		return err
	}

	if !valid {
		return ErrInvalidOrderNumber
	}

	return nil
}

func (s *balanceSvc) ListUserOrders(ctx context.Context, payload *genBalance.ListUserOrdersPayload) (res *genBalance.ListUserOrdersResult, err error) {

	ctx, err = s.Auther.JWTAuth(ctx, payload.Authorization, nil)
	if err != nil {
		return nil, err
	}

	userID, err := s.Auther.UserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	ordersByUserID, err := s.RetrieaveUserOrders(ctx, userID)
	if err != nil {
		return nil, err
	}

	res = new(genBalance.ListUserOrdersResult)
	if ordersByUserID == nil {
		noOrders := "yes"
		res.NoOrders = &noOrders
		return res, nil
	}

	for _, v := range ordersByUserID {
		userOrder := &genBalance.Order{
			Number:     v.Number,
			Status:     v.Status,
			UploadedAt: v.CreatedAt.Format(time.RFC3339),
		}
		res.Orders = append(res.Orders, userOrder)
	}

	return res, nil
}

func (s *balanceSvc) GetUserBalance(ctx context.Context, payload *genBalance.GetUserBalancePayload) (res *genBalance.GetUserBalanceResult, err error) {
	ctx, err = s.Auther.JWTAuth(ctx, payload.Authorization, nil)
	if err != nil {
		return nil, err
	}

	userID, err := s.Auther.UserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	userBalance, err := s.Balance.Retrieve(ctx, userID)
	if err != nil {
		return &genBalance.GetUserBalanceResult{}, err
	}
	return &genBalance.GetUserBalanceResult{
		Current:   float64((userBalance.Current / 100)),
		Withdrawn: float64((userBalance.WithdrawnSum / 100)),
	}, nil
}

func (s *balanceSvc) WithdrawUserBalance(context.Context, *genBalance.WithdrawUserBalancePayload) (err error) {
	return nil
}

func (s *balanceSvc) ProcessAccruals(ctx context.Context, client genAccrualHTTPClient.Client) error {
	_ = client
	<-ctx.Done()
	return nil
}
